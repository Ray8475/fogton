# Техническое видение (Vision) — Gifts Futures Telegram App

Этот документ — **отправная точка для MVP** и “технический проект” для последующей разработки.
Цель — максимально простая реализация по принципам **KISS** без оверинжиниринга.

Основа идеи: `idea.md`.

## Оглавление
- Технологии
- Принцип разработки (KISS)
- Структура проекта
- Архитектура проекта
- Модель данных
- Работа с Telegram App (Mini App + Bot)
- Мониторинг
- Сценарии работы (MVP)
- Деплой
- Конфигурирование
- Логгирование
- Подход к логгированию

---

## Технологии

### Telegram
- **Формат**: Telegram **Mini App (WebApp)** + **Bot**
  - Bot: входная точка, меню, deep-links, уведомления
  - Mini App: основной UI (рынок, портфель, депозит, сделки)

### Backend
- **Язык**: Python 3.12
- **API**: FastAPI
- **Бот**: aiogram

### Данные
- **БД (MVP)**: SQLite
- **ORM**: SQLAlchemy 2
- **Миграции**: Alembic
- **Дальше (после MVP)**: переезд на Postgres без смены моделей/слоёв

### Frontend (Mini App)
- **UI**: HTML + Tailwind (CDN)
- **Логика**: vanilla JS
- Примечание: без React/Vue на MVP, чтобы снизить сложность и ускорить проверку гипотезы.

### Аутентификация
- **Telegram WebApp initData**: backend проверяет подпись `initData` и извлекает идентификатор пользователя.

### Платежи (депозиты в сети TON)
- **Активы**: TON и USDT (jetton) в сети TON
- **Модель (MVP, KISS)**: **кастодиальная**
  - депозиты приходят на **кошелёк проекта**
  - пользователю начисляется **внутренний баланс** в приложении
- **Атрибуция депозита пользователю (MVP)**:
  - **один кошелёк проекта** + **уникальный комментарий/пэйлоад** (memo) в переводе
- **Опционально позже**:
  - **уникальный депозитный адрес** на пользователя (если понадобится улучшить UX/надёжность сопоставления)

---

## Принцип разработки (KISS)

### Правила MVP
- **Фокус**: проверить спрос на “фьючерсы на подарки” и базовый пользовательский поток (депозит → сделки → портфель).
- **Рынки**: **несколько подарков** (набор ограничен и ручной на старте).
- **Экспирации**: **фиксированный набор** (например 7 и 30 дней).
- **Без оверинжиниринга**: сначала корректность балансов/учёта операций, потом сложные торговые механики.

### Торговая модель
- **TBD**: будет определена позже по отдельному согласованию (не фиксируем сейчас, чтобы не принять неверные решения в архитектуре).

---

## Структура проекта

### Репозиторий
- **Один репозиторий (monorepo)**:
  - `backend/` — FastAPI (API) + служебные задачи (мониторинг депозитов), общая бизнес-логика
  - `bot/` — aiogram бот (взаимодействие в чате, ссылки/кнопки на Mini App, уведомления)
  - `webapp/` — Telegram Mini App (статический фронт)

### Запуск (MVP)
- **Два процесса**:
  - `api` (FastAPI)
  - `bot` (aiogram)
  
Примечание: два процесса проще изолировать и наблюдать (логи/рестарты), даже если это чуть сложнее, чем “всё в одном”.

### API стиль (для Mini App)
- **REST + JSON**: небольшой набор простых эндпоинтов (без GraphQL/RPC-слоёв на MVP).

---

## Архитектура проекта

### Компоненты (MVP)
- **Mini App (webapp)**: UI, ходит в backend по REST+JSON, передаёт `initData`.
- **Backend API (FastAPI)**:
  - проверяет `initData`, выдаёт данные (рынок/портфель/депозит-инструкции),
  - ведёт учёт балансов и операций,
  - принимает вебхуки по депозитам.
- **Bot (aiogram)**: запуск Mini App, команды, уведомления.
- **TON webhook endpoint (в API)**: вход для событий от провайдера TON API (депозиты TON/USDT).

### Фоновые задачи (KISS)
- **Без брокера очередей** (Redis/RabbitMQ не используем на MVP).
- Если понадобится периодический пересчёт/проверка — используем простой scheduler/async-task внутри API (минимально).

### Поток депозита (TON/USDT)
- Провайдер TON API отправляет **webhook** на наш API.
- API валидирует событие, сопоставляет пользователя (по comment/payload), делает запись операции и увеличивает внутренний баланс.

---

## Модель данных

Цель модели данных — **надёжный учёт денег и позиций** при минимуме таблиц.

### Справочники
- `users`
  - `id`
  - `telegram_user_id` (уникальный)
  - `created_at`
- `gifts`
  - `id`
  - `name`
  - `is_active`
- `expiries`
  - `id`
  - `days` (например 7, 30)
  - `settlement_at` (дата/время расчёта)
  - `is_active`
- `markets`
  - `id`
  - `gift_id`
  - `expiry_id`
  - `is_active`

### Балансы и операции (денежный учёт)
- `balances`
  - `id`
  - `user_id`
  - `currency` (`TON` | `USDT`)
  - `available` (Decimal)
  - `reserved` (Decimal, можно держать 0 на MVP если нет резерва)
- `ledger_entries`
  - `id`
  - `user_id`
  - `currency` (`TON` | `USDT`)
  - `delta` (Decimal, + или -)
  - `reason` (например `deposit`, `trade`, `withdraw`, `adjustment`)
  - `ref_type` / `ref_id` (ссылка на депозит/сделку и т.п.)
  - `created_at`

Примечание: `ledger_entries` — основной источник правды для аудита. `balances` можно обновлять из ledger транзакционно.

### Депозиты (TON/USDT)
- `deposits`
  - `id`
  - `user_id`
  - `currency` (`TON` | `USDT`)
  - `amount` (Decimal)
  - `tx_hash` (уникальный)
  - `comment_payload` (то, по чему сопоставили пользователя)
  - `status` (`received` | `credited` | `rejected`)
  - `received_at`

### Торговля (пока без конкретной торговой модели)
- `positions`
  - `id`
  - `user_id`
  - `market_id`
  - `side` (`long` | `short`)
  - `qty` (Decimal)
  - `avg_price` (Decimal)
  - `updated_at`
- `trades`
  - `id`
  - `user_id`
  - `market_id`
  - `side` (`buy` | `sell`)
  - `qty` (Decimal)
  - `price` (Decimal)
  - `fee_currency` (опционально)
  - `fee_amount` (опционально)
  - `created_at`

Примечание: конкретная логика расчёта `price`/PNL зависит от согласования торговой модели (TBD), но данные для учёта long/short уже предусмотрены.

---

## Работа с Telegram App (Mini App + Bot)

### Mini App → Backend (auth)
- Первый запрос из Mini App содержит `initData`.
- Backend проверяет подпись `initData`, создаёт/находит пользователя и выдаёт **короткоживущий JWT** (например 1–6 часов).
- Дальше Mini App ходит в API с `Authorization: Bearer <jwt>`.

### Bot (получение апдейтов)
- **Webhook**: бот получает апдейты через HTTPS webhook.
- Бот отдаёт пользователю кнопку/ссылку для открытия Mini App и может отправлять уведомления.

---

## Мониторинг

### MVP (KISS)
- **Только логи** (без Prometheus/Grafana/Sentry на старте).
- **Healthchecks**:
  - `GET /healthz` для API
  - отдельный простой healthcheck для бота (например HTTP endpoint в bot-процессе или “самопроверка” при старте/по команде)
  - проверка доступности webhook-роутов (API принимает запросы)

---

## Сценарии работы (MVP)

### 1) Онбординг
- Пользователь открывает бота → нажимает кнопку “Открыть приложение”.
- Mini App открывается и делает первый запрос в API с `initData` → получает JWT.

### 2) Депозит TON/USDT (TON network)
- Mini App показывает пользователю **адрес кошелька проекта** и **уникальный comment/payload** для перевода.
- Пользователь отправляет TON или USDT (jetton) с указанным comment/payload.
- Провайдер TON API шлёт webhook → API создаёт запись `deposits` и делает `ledger_entries` → увеличивает `balances.available`.

### 3) Торговля (без фиксации торговой модели)
- Mini App показывает рынки `(gift, expiry)` и позиции пользователя.
- Пользователь открывает **long** или **short** позицию (детали ценообразования/исполнения — TBD).
- API пишет `trades`, обновляет `positions`, отражает изменения в `ledger_entries`/балансах (комиссия/списания — по будущей модели).

### 4) Вывод средств (withdraw) — автоматический
- Пользователь создаёт заявку на вывод (amount + destination TON address).
- API проверяет доступный баланс, создаёт запись `withdrawals`, инициирует on-chain транзакцию с кошелька проекта и фиксирует `tx_hash`.
- После подтверждения сети API помечает вывод как `completed` и делает соответствующую запись в `ledger_entries`.

### 5) Админка (KISS)
- Минимальные **админ REST-эндпоинты**, закрытые отдельным токеном:
  - включить/выключить `gifts`, `expiries`, `markets`
  - корректировка балансов (только при необходимости, с записью в `ledger_entries`)

---

## Деплой

### MVP (самый быстрый путь)
- Запуск локально (Windows) + **туннель** (ngrok / Cloudflare Tunnel) для публичного HTTPS:
  - webhook Telegram (бот)
  - webhook провайдера TON API (депозиты)
- Mini App может быть:
  - статикой, раздаваемой локально (через API), или
  - загруженной на простой static-hosting (опционально), главное — чтобы была доступна по HTTPS.

---

## Конфигурирование

### MVP (KISS)
- **Только env-переменные** (через `.env` локально и переменные окружения на деплое).
- Конфиги делим по областям:
  - Telegram: `BOT_TOKEN`, `WEBHOOK_BASE_URL`, `WEBHOOK_SECRET` (если используем)
  - DB: `DATABASE_URL`
  - TON: ключи/URL провайдера, адрес кошелька проекта, секрет для вебхуков
  - Security: `JWT_SECRET`, `ADMIN_TOKEN`

---

## Логгирование

### MVP
- **JSON-логи** во всех процессах (api/bot) с одинаковыми полями.
- Минимальный набор полей:
  - `timestamp`, `level`, `service` (`api`|`bot`), `event`, `message`
  - `request_id` (для API), `telegram_user_id` (если есть), `tx_hash` (для депозитов/выводов)
- Ошибки логируем с stacktrace.

---

## Подход к логгированию

### Принципы (KISS)
- Логи — основной инструмент диагностики на MVP (без сложного мониторинга).
- **Одна структура логов** для всех сервисов (api/bot), чтобы можно было быстро фильтровать и искать.

### Что обязательно логируем
- **API**: входящий запрос (метод/путь), `request_id`, пользователь (если известен), код ответа, время выполнения.
- **Auth**: успех/ошибка валидации `initData` (без утечки секретов и полного `initData`).
- **TON webhooks**: получение события, `tx_hash`, валюта, сумма, результат атрибуции пользователя, статус зачисления.
- **Withdraw**: создание заявки, попытка отправки on-chain, `tx_hash`, финальный статус.
- **Админ действия**: включение/выключение рынков, корректировки — всегда с причиной.

### Чего не логируем
- Секреты (`BOT_TOKEN`, `JWT_SECRET`, ключи TON), приватные ключи, полный payload с чувствительными данными.

